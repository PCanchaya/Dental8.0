// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 5fac0881a4f2bb24 "Patrick Dental (React Export)", do not edit manually */
// /:https://framerusercontent.com/modules/UIrMjSS6ZX89L0CsT8k6/drtHMgOaYx15q3L9z75d/Carousel.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Children, useCallback as useCallback2, useEffect as useEffect7, useState as useState3, useRef as useRef3, cloneElement, startTransition } from "react";
import { addPropertyControls, ControlType as ControlType4, RenderTarget as RenderTarget3 } from "unframer";
import { scroll, resize } from "@motionone/dom";
import { clamp } from "@motionone/utils";
import { animate as animate2, motion, useMotionValue, useTransform, useReducedMotion } from "unframer";

// /:https://framerusercontent.com/modules/VTUDdizacRHpwbkOamr7/AykinQJbgwl92LvMGZwu/constants.js
import { ControlType } from "unframer";
var containerStyles = {
  position: "relative",
  width: "100%",
  height: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
};
var emptyStateStyle = {
  ...containerStyles,
  borderRadius: 6,
  background: "rgba(136, 85, 255, 0.3)",
  color: "#85F",
  border: "1px dashed #85F",
  flexDirection: "column"
};
var defaultEvents = {
  onClick: {
    type: ControlType.EventHandler
  },
  onMouseEnter: {
    type: ControlType.EventHandler
  },
  onMouseLeave: {
    type: ControlType.EventHandler
  }
};
var fontSizeOptions = {
  type: ControlType.Number,
  title: "Font Size",
  min: 2,
  max: 200,
  step: 1,
  displayStepper: true
};
var fontControls = {
  font: {
    type: ControlType.Boolean,
    title: "Font",
    defaultValue: false,
    disabledTitle: "Default",
    enabledTitle: "Custom"
  },
  fontFamily: {
    type: ControlType.String,
    title: "Family",
    placeholder: "Inter",
    hidden: ({ font }) => !font
  },
  fontWeight: {
    type: ControlType.Enum,
    title: "Weight",
    options: [
      100,
      200,
      300,
      400,
      500,
      600,
      700,
      800,
      900
    ],
    optionTitles: [
      "Thin",
      "Extra-light",
      "Light",
      "Regular",
      "Medium",
      "Semi-bold",
      "Bold",
      "Extra-bold",
      "Black"
    ],
    hidden: ({ font }) => !font
  }
};

// /:https://framerusercontent.com/modules/D4TWeLfcxT6Tysr2BlYg/iZjmqdxVx1EOiM3k1FaW/useOnNavigationTargetChange.js
import { useIsInCurrentNavigationTarget } from "unframer";
import { useEffect } from "react";
function useOnEnter(onEnter, enabled) {
  return useOnSpecificTargetChange(true, onEnter, enabled);
}
function useOnExit(onExit, enabled) {
  return useOnSpecificTargetChange(false, onExit, enabled);
}
function useOnSpecificTargetChange(goal, callback, enabled = true) {
  const isInTarget = useIsInCurrentNavigationTarget();
  useEffect(() => {
    if (enabled && isInTarget === goal) callback();
  }, [
    isInTarget
  ]);
}

// /:https://framerusercontent.com/modules/ExNgrA7EJTKUPpH6vIlN/eiOrSJ2Ab5M9jPCvVwUz/useConstant.js
import { useRef } from "react";

// /:https://framerusercontent.com/modules/D2Lz5CmnNVPZFFiZXalt/QaCzPbriZBfXWZIIycFI/colorFromToken.js
import { Color } from "unframer";

// /:https://framerusercontent.com/modules/3mKFSGQqKHV82uOV1eBc/5fbRLvOpxZC0JOXugvwm/isMotionValue.js
import { MotionValue } from "unframer";

// /:https://framerusercontent.com/modules/xDiQsqBGXzmMsv7AlEVy/uhunpMiNsbXxzjlXsg1y/useUniqueClassName.js
import * as React from "react";

// /:https://framerusercontent.com/modules/ETACN5BJyFTSo0VVDJfu/NHRqowOiXkF9UwOzczF7/variantUtils.js
import { ControlType as ControlType2 } from "unframer";

// /:https://framerusercontent.com/modules/eMBrwoqQK7h6mEeGQUH8/GuplvPJVjmxpk9zqOTcb/isBrowser.js
import { useMemo } from "react";
var __unframerNavigator = typeof window !== "undefined" ? navigator : void 0;
var isBrowserSafari = () => {
  if (typeof __unframerNavigator !== `undefined`) {
    const userAgent = __unframerNavigator.userAgent.toLowerCase();
    const isSafari = (userAgent.indexOf("safari") > -1 || userAgent.indexOf("framermobile") > -1 || userAgent.indexOf("framerx") > -1) && userAgent.indexOf("chrome") < 0;
    return isSafari;
  } else return false;
};
var useIsBrowserSafari = () => useMemo(
  () => isBrowserSafari(),
  []
);

// /:https://framerusercontent.com/modules/v9AWX2URmiYsHf7GbctE/XxKAZ9KlhWqf5x1JMyyF/useOnChange.js
import { useEffect as useEffect3 } from "react";

// /:https://framerusercontent.com/modules/kNDwabfjDEb3vUxkQlZS/fSIr3AOAYbGlfSPgXpYu/useAutoMotionValue.js
import { useCallback, useEffect as useEffect4, useRef as useRef2 } from "react";
import { motionValue, animate, RenderTarget } from "unframer";

// /:https://framerusercontent.com/modules/cuQH4dmpDnV8YK1mSgQX/KqRXqunFjE6ufhpc7ZRu/useFontControls.js
import { fontStore } from "unframer";
import { useEffect as useEffect5 } from "react";

// /:https://framerusercontent.com/modules/afBE9Yx1W6bY5q32qPxe/m3q7puE2tbo1S2C0s0CT/useRenderTarget.js
import { useMemo as useMemo2 } from "react";
import { RenderTarget as RenderTarget2 } from "unframer";
function useRenderTarget() {
  const currentRenderTarget = useMemo2(
    () => RenderTarget2.current(),
    []
  );
  return currentRenderTarget;
}
function useIsOnCanvas() {
  const onCanvas = useMemo2(
    () => RenderTarget2.current() === RenderTarget2.canvas,
    []
  );
  return onCanvas;
}

// /:https://framerusercontent.com/modules/zGkoP8tPDCkoBzMdt5uq/0zFSjxIYliHxrQQnryFX/useControlledState.js
import * as React2 from "react";

// /:https://framerusercontent.com/modules/5SM58HxZHxjjv7aLMOgQ/WXz9i6mVki0bBCrKdqB3/propUtils.js
import { useMemo as useMemo3 } from "react";
import { ControlType as ControlType3 } from "unframer";
function useRadius(props) {
  const { borderRadius, isMixedBorderRadius, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius } = props;
  const radiusValue = useMemo3(
    () => isMixedBorderRadius ? `${topLeftRadius}px ${topRightRadius}px ${bottomRightRadius}px ${bottomLeftRadius}px` : `${borderRadius}px`,
    [
      borderRadius,
      isMixedBorderRadius,
      topLeftRadius,
      topRightRadius,
      bottomRightRadius,
      bottomLeftRadius
    ]
  );
  return radiusValue;
}
var borderRadiusControl = {
  borderRadius: {
    title: "Radius",
    type: ControlType3.FusedNumber,
    toggleKey: "isMixedBorderRadius",
    toggleTitles: [
      "Radius",
      "Radius per corner"
    ],
    valueKeys: [
      "topLeftRadius",
      "topRightRadius",
      "bottomRightRadius",
      "bottomLeftRadius"
    ],
    valueLabels: [
      "TL",
      "TR",
      "BR",
      "BL"
    ],
    min: 0
  }
};
function usePadding(props) {
  const { padding, paddingPerSide, paddingTop, paddingRight, paddingBottom, paddingLeft } = props;
  const paddingValue = useMemo3(
    () => paddingPerSide ? `${paddingTop}px ${paddingRight}px ${paddingBottom}px ${paddingLeft}px` : padding,
    [
      padding,
      paddingPerSide,
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft
    ]
  );
  return paddingValue;
}
var paddingControl = {
  padding: {
    type: ControlType3.FusedNumber,
    toggleKey: "paddingPerSide",
    toggleTitles: [
      "Padding",
      "Padding per side"
    ],
    valueKeys: [
      "paddingTop",
      "paddingRight",
      "paddingBottom",
      "paddingLeft"
    ],
    valueLabels: [
      "T",
      "R",
      "B",
      "L"
    ],
    min: 0,
    title: "Padding"
  }
};

// /:https://framerusercontent.com/modules/UIrMjSS6ZX89L0CsT8k6/drtHMgOaYx15q3L9z75d/Carousel.js
function calcMaskWidth([inset, width]) {
  return inset + (100 - inset) * (width / 100) * 0.5;
}
function checkLimit(progress, target, { edgeOpacity, moreItems, buttonRef }, transition) {
  if (moreItems.current && progress === target) {
    moreItems.current = false;
    animate2(edgeOpacity, 1, transition);
    buttonRef.current?.setAttribute("disabled", "");
  } else if (!moreItems.current && progress !== target) {
    moreItems.current = true;
    animate2(edgeOpacity, 0, transition);
    buttonRef.current?.removeAttribute("disabled");
  }
}
function useGUI(initialMoreItems, initialAlpha) {
  const moreItems = useRef3(initialMoreItems);
  const edgeOpacity = useMotionValue(moreItems.current ? 0 : 1);
  const fadeOpacity = useTransform(edgeOpacity, [0, 1], [initialAlpha || 0, 1]);
  const buttonOpacity = useTransform(edgeOpacity, (v) => 1 - v);
  const buttonRef = useRef3(null);
  const pointerEvents = useTransform(buttonOpacity, (v) => v > 0.2 ? "auto" : "none");
  const cursor = useTransform(pointerEvents, (v) => v === "auto" ? "pointer" : "default");
  const buttonStyle = { ...baseButtonStyles, opacity: buttonOpacity, pointerEvents, cursor };
  return { moreItems, fadeOpacity, edgeOpacity, buttonStyle, buttonRef };
}
function setAriaVisible({ element }) {
  element.setAttribute("aria-hidden", false);
}
function useScrollLimits(container, axis, directionModifier, scrollInfo, updateCurrentScroll, targetScroll, checkLimits, measureItems) {
  useEffect7(() => {
    if (!container.current) return;
    const updateScrollInfo = (info) => {
      scrollInfo.current = info[axis];
      if (info[axis].current * directionModifier === targetScroll.current) {
        targetScroll.current = void 0;
      }
      updateCurrentScroll(info[axis].current);
      checkLimits();
    };
    const stopScroll = scroll(updateScrollInfo, { container: container.current, axis });
    const stopResize = resize(container.current, () => {
      measureItems();
      checkLimits();
    });
    return () => {
      stopScroll();
      stopResize();
    };
  }, [checkLimits, measureItems]);
}
function Carousel({ slots, gap, axis, align, sizingObject, fadeObject, arrowObject, snapObject, progressObject, ariaLabel, borderRadius, effectsObject, ...props }) {
  const filteredSlots = slots?.filter(Boolean);
  const numItems = Children.count(filteredSlots);
  const isCanvas = RenderTarget3.current() === RenderTarget3.canvas;
  const writingDirection = useWritingDirection();
  const directionModifier = axis && writingDirection === "rtl" ? -1 : 1;
  const padding = usePadding(props);
  const axisLabel = axis ? "x" : "y";
  const { fadeContent, fadeWidth, fadeInset, fadeTransition, fadeAlpha } = fadeObject;
  const { snap, snapEdge, fluid } = snapObject;
  const { widthType, widthInset, widthColumns, heightType, heightInset, heightRows } = sizingObject;
  const { showScrollbar, showProgressDots, dotSize, dotsInset, dotsRadius, dotsPadding, dotsGap, dotsFill, dotsBackground, dotsActiveOpacity, dotsOpacity, dotsBlur } = progressObject;
  const { showMouseControls, arrowSize, arrowRadius, arrowFill, leftArrow, rightArrow, arrowPadding } = arrowObject;
  const scrollInfo = useRef3(void 0);
  const targetScroll = useRef3(void 0);
  const currentScroll = useMotionValue(0);
  const updateCurrentScroll = (newScroll) => {
    currentScroll.set(targetScroll.current !== void 0 ? targetScroll.current : newScroll);
  };
  const start = useGUI(writingDirection === "rtl", fadeAlpha);
  const end = useGUI(writingDirection !== "rtl", fadeAlpha);
  const startMaskInset = useMotionValue(fadeInset * 0.5);
  const endMaskInset = useTransform(startMaskInset, (v) => 100 - v);
  const baseWidth = useMotionValue(fadeWidth);
  const startMaskWidth = useTransform([startMaskInset, baseWidth], calcMaskWidth);
  const endMaskWidth = useTransform(startMaskWidth, (v) => 100 - v);
  const direction = useMotionValue(axis ? "right" : "bottom");
  const mask = useTransform([direction, start.fadeOpacity, startMaskInset, startMaskWidth, end.fadeOpacity, endMaskInset, endMaskWidth], (latest) => {
    return `linear-gradient(to ${latest[0]}, rgb(0, 0, 0, ${latest[1]}) ${latest[2]}%, rgb(0, 0, 0, 1) ${latest[3]}%, rgba(0, 0, 0, 1) ${latest[6]}%, rgb(0, 0, 0, ${latest[4]}) ${latest[5]}%)`;
  });
  const carouselRef = useRef3(null);
  const [numPages, setNumPages] = useState3(isCanvas ? 4 : 1);
  const itemStyle = { scrollSnapAlign: snapEdge, flexShrink: 0 };
  const childStyle = {};
  if (align === "stretch") {
    if (axis) {
      childStyle.height = "100%";
      itemStyle.height = "auto";
    } else {
      childStyle.width = "100%";
      itemStyle.width = "auto";
    }
  }
  if (!fluid) {
    itemStyle.scrollSnapStop = "always";
  }
  if (widthType === "stretch") {
    itemStyle.width = `calc(100% - ${widthInset || 0}px)`;
    childStyle.width = "100%";
  } else if (widthType === "columns") {
    itemStyle.width = `calc(${100 / widthColumns}% - ${gap}px + ${gap / widthColumns}px)`;
    childStyle.width = "100%";
  }
  if (heightType === "stretch") {
    itemStyle.height = `calc(100% - ${heightInset || 0}px)`;
    childStyle.height = "100%";
  } else if (heightType === "rows") {
    itemStyle.height = `calc(${100 / heightRows}% - ${gap}px + ${gap / heightRows}px)`;
    childStyle.height = "100%";
  }
  const scrollOverflow = isCanvas ? "hidden" : "auto";
  const containerStyle = { ...baseContainerStyle, padding };
  const carouselStyle = { ...baseCarouselStyle, gap, alignItems: align, flexDirection: axis ? "row" : "column", overflowX: axis ? scrollOverflow : "hidden", overflowY: axis ? "hidden" : scrollOverflow, scrollSnapType: snap ? `${axisLabel} mandatory` : void 0, WebkitOverflowScrolling: "touch", WebkitMaskImage: fadeContent ? mask : void 0, maskImage: fadeContent ? mask : void 0, borderRadius };
  const carouselA11y = { ["aria-roledescription"]: "carousel" };
  if (ariaLabel) {
    carouselA11y["aria-title"] = ariaLabel;
  }
  const itemA11y = {};
  if (align === "stretch") {
    itemA11y["aria-role"] = "group";
    itemA11y["aria-roledescription"] = "slide";
  }
  if (!isCanvas) {
    const itemSizes = useRef3([]);
    useScrollLimits(carouselRef, axisLabel, directionModifier, scrollInfo, updateCurrentScroll, targetScroll, useCallback2(() => {
      if (!scrollInfo.current) return;
      const { targetLength, containerLength, scrollLength } = scrollInfo.current;
      const current = currentScroll.get();
      if (!targetLength && !containerLength) return;
      if (targetLength > containerLength) {
        checkLimit(current * directionModifier, 0, start, fadeTransition);
        checkLimit(current * directionModifier, scrollLength, end, fadeTransition);
        for (let i = 0; i < itemSizes.current.length; i++) {
          const { element, start: start2, end: end2 } = itemSizes.current[i];
          const outOfView = end2 < current || start2 > current + containerLength;
          element.setAttribute("aria-hidden", outOfView);
          if (!outOfView) {
            element.querySelectorAll("button,a").forEach((el) => {
              const orig = el.dataset.origTabIndex;
              if (orig) el.tabIndex = orig;
              else el.removeAttribute("tabIndex");
            });
          } else {
            element.querySelectorAll("button,a").forEach((el) => {
              const orig = el.getAttribute("tabIndex");
              if (orig) el.dataset.origTabIndex = orig;
              el.tabIndex = -1;
            });
          }
        }
      } else {
        checkLimit(0, 0, start, fadeTransition);
        checkLimit(1, 1, end, fadeTransition);
        itemSizes.current.forEach(setAriaVisible);
      }
      let newNumPages = Math.ceil(targetLength / containerLength);
      if (!isNaN(newNumPages)) {
        if (newNumPages / numItems > 0.65) newNumPages = numItems;
        if (newNumPages !== numPages) setNumPages(newNumPages);
      }
    }, [numPages]), useCallback2(() => {
      if (!carouselRef.current) return;
      itemSizes.current = Array.from(carouselRef.current.children).map((element) => {
        return axis ? { element, start: element.offsetLeft, end: element.offsetLeft + element.offsetWidth } : { element, start: element.offsetTop, end: element.offsetTop + element.offsetHeight };
      });
    }, []));
  }
  if (isCanvas) {
    useEffect7(() => {
      baseWidth.set(fadeWidth);
    }, [fadeWidth]);
    useEffect7(() => {
      startMaskInset.set(fadeInset * 0.5);
    }, [fadeInset]);
    useEffect7(() => {
      direction.set(axis ? "right" : "bottom");
    }, [axis]);
  }
  const isReducedMotion = useReducedMotion();
  const goto = (scrollTo) => {
    targetScroll.current = scrollTo;
    const options = axis ? { left: scrollTo } : { top: scrollTo };
    carouselRef.current.scrollTo({ ...options, behavior: isReducedMotion ? "auto" : "smooth" });
  };
  const gotoPage = (page, adjustment = 0) => {
    if (!scrollInfo.current) return;
    const { scrollLength } = scrollInfo.current;
    const totalLen = scrollLength / (numPages - 1);
    goto((page * totalLen + adjustment * totalLen) * directionModifier);
  };
  const gotoDelta = (delta) => () => {
    if (!scrollInfo.current) return;
    const { containerLength, scrollLength } = scrollInfo.current;
    const current = currentScroll.get() * directionModifier;
    const pageLength = scrollLength / numPages;
    const currentPage = clamp(0, numPages - 1, Math.floor(current / pageLength));
    let adjustment = 0;
    if (snap && (snapEdge === "start" || snapEdge === "end") && delta >= 1) adjustment = 0.4;
    gotoPage(currentPage + delta, adjustment);
  };
  if (numItems === 0) {
    return /* @__PURE__ */ _jsx(Placeholder, {});
  }
  const dots = [];
  const dotsBlurStyle = {};
  if (numPages > 1 && showProgressDots && !showScrollbar) {
    for (let i = 0; i < numPages; i++) {
      const isSelected = isCanvas && !i || false;
      dots.push(/* @__PURE__ */ _jsx(Dot, { dotStyle: { ...dotStyle, width: dotSize, height: dotSize, backgroundColor: dotsFill }, buttonStyle: baseButtonStyles, isSelected, selectedOpacity: dotsActiveOpacity, opacity: dotsOpacity, onClick: () => startTransition(() => gotoPage(i)), currentScroll, scrollInfo, total: numPages, index: i, gap: dotsGap, padding: dotsPadding, axis, directionModifier }));
    }
    if (dotsBlur) {
      dotsBlurStyle.backdropFilter = dotsBlurStyle.WebkitBackdropFilter = `blur(${dotsBlur}px)`;
    }
  }
  const leftArrowSrc = leftArrow || "https://framerusercontent.com/images/6tTbkXggWgQCAJ4DO2QEdXXmgM.svg";
  const rightArrowSrc = rightArrow || "https://framerusercontent.com/images/11KSGbIZoRSg4pjdnUoif6MKHI.svg";
  return /* @__PURE__ */ _jsxs("section", { style: containerStyle, ...carouselA11y, children: [/* @__PURE__ */ _jsx(motion.ul, { ref: carouselRef, style: carouselStyle, className: "framer--carousel", "data-show-scrollbar": showScrollbar, "aria-atomic": "false", "aria-live": "polite", onWheel: () => targetScroll.current = void 0, children: Children.map(filteredSlots, (child, index) => /* @__PURE__ */ _jsx("li", { style: itemStyle, ...itemA11y, "aria-label": `${index + 1} of ${numItems}`, children: /* @__PURE__ */ cloneElement(child, { ...child.props, style: { ...child.props?.style, ...childStyle } }) })) }), /* @__PURE__ */ _jsxs("fieldset", { style: { ...controlsStyles, padding: arrowPadding, display: "flex", flexDirection: axis ? "row" : "column" }, "aria-label": "Carousel pagination controls", className: "framer--carousel-controls", "data-show-mouse-controls": showMouseControls, children: [
    // isMouseDevice &&
    /* @__PURE__ */ _jsx(motion.button, { ref: start.buttonRef, type: "button", style: { ...start.buttonStyle, backgroundColor: arrowFill, width: arrowSize, height: arrowSize, borderRadius: arrowRadius, rotate: !axis ? 90 : 0, display: showMouseControls ? "block" : "none" }, onClick: gotoDelta(-1), "aria-label": "Previous", whileTap: { scale: 0.9 }, transition: { duration: 0.05 }, children: /* @__PURE__ */ _jsx("img", { decoding: "async", alt: "", width: arrowSize, height: arrowSize, src: writingDirection === "rtl" && axis ? rightArrowSrc : leftArrowSrc }) }),
    // isMouseDevice &&
    /* @__PURE__ */ _jsx(motion.button, { ref: end.buttonRef, type: "button", style: { ...end.buttonStyle, backgroundColor: arrowFill, width: arrowSize, height: arrowSize, borderRadius: arrowRadius, rotate: !axis ? 90 : 0, display: showMouseControls ? "block" : "none" }, onClick: gotoDelta(1), "aria-label": "Next", whileTap: { scale: 0.9 }, transition: { duration: 0.05 }, children: /* @__PURE__ */ _jsx("img", { decoding: "async", alt: "", width: arrowSize, height: arrowSize, src: writingDirection === "rtl" && axis ? leftArrowSrc : rightArrowSrc }) }),
    dots.length > 1 ? /* @__PURE__ */ _jsx("div", { style: { ...dotsContainerStyle, left: axis ? "50%" : dotsInset, top: !axis ? "50%" : "unset", transform: axis ? "translateX(-50%)" : "translateY(-50%)", flexDirection: axis ? "row" : "column", bottom: axis ? dotsInset : "unset", borderRadius: dotsRadius, backgroundColor: dotsBackground, ...dotsBlurStyle }, children: dots }) : null
  ] }), /* @__PURE__ */ _jsx(MouseStyles, {})] });
}
Carousel.defaultProps = { gap: 10, padding: 10, progressObject: { showScrollbar: false, showProgressDots: false }, sizingObject: { widthType: "auto", widthOffset: 0, widthColumns: 2, heightType: "auto", heightOffset: 0, heightRows: 2 }, borderRadius: 0 };
addPropertyControls(Carousel, { slots: { type: ControlType4.Array, title: "Children", control: { type: ControlType4.ComponentInstance } }, axis: { type: ControlType4.Enum, title: "Direction", options: [true, false], optionIcons: ["direction-horizontal", "direction-vertical"], displaySegmentedControl: true }, align: { type: ControlType4.Enum, title: "Align", options: ["flex-start", "center", "flex-end"], optionIcons: { axis: { true: ["align-top", "align-middle", "align-bottom"], false: ["align-left", "align-center", "align-right"] } }, defaultValue: "center", displaySegmentedControl: true }, gap: { type: ControlType4.Number, title: "Gap" }, ...paddingControl, sizingObject: { type: ControlType4.Object, title: "Sizing", controls: { widthType: { type: ControlType4.Enum, title: "Width", options: ["auto", "stretch", "columns"], optionTitles: ["Auto", "Stretch", "Columns"], defaultValue: "auto" }, widthInset: { type: ControlType4.Number, title: "Inset", min: 0, max: 500, defaultValue: 0, hidden: (props) => props.widthType !== "stretch" }, widthColumns: { type: ControlType4.Number, title: "Columns", min: 1, max: 10, defaultValue: 2, displayStepper: true, hidden: (props) => props.widthType !== "columns" }, heightType: { type: ControlType4.Enum, title: "Height", options: ["auto", "stretch", "rows"], optionTitles: ["Auto", "Stretch", "Rows"], defaultValue: "auto" }, heightInset: { type: ControlType4.Number, title: "Inset", min: 0, max: 500, defaultValue: 0, hidden: (props) => props.heightType !== "stretch" }, heightRows: { type: ControlType4.Number, title: "Rows", min: 1, max: 10, defaultValue: 2, displayStepper: true, hidden: (props) => props.heightType !== "rows" } } }, snapObject: { type: ControlType4.Object, title: "Snapping", controls: { snap: { type: ControlType4.Boolean, title: "Enable" }, snapEdge: { type: ControlType4.Enum, title: "Edge", options: ["start", "center", "end"], optionTitles: ["Left", "Center", "Right"], defaultValue: "center", hidden: (props) => !props.snap }, fluid: { type: ControlType4.Boolean, title: "Fluid", defaultValue: false, hidden: (props) => !props.snap } } }, fadeObject: { type: ControlType4.Object, title: "Fading", controls: { fadeContent: { type: ControlType4.Boolean, title: "Enable", defaultValue: false }, fadeWidth: { type: ControlType4.Number, title: "Width", defaultValue: 25, min: 0, max: 100, unit: "%", hidden: (props) => !props.fadeContent }, fadeInset: { type: ControlType4.Number, title: "Inset", defaultValue: 0, min: 0, max: 100, unit: "%", hidden: (props) => !props.fadeContent }, fadeAlpha: { type: ControlType4.Number, title: "Opacity", hidden: (props) => !props.fadeContent, min: 0, max: 1, step: 0.05, defaultValue: 0 }, fadeTransition: { type: ControlType4.Transition, title: "Transition", hidden: (props) => !props.fadeContent } } }, progressObject: { type: ControlType4.Object, title: "Progress", controls: { showScrollbar: { type: ControlType4.Boolean, title: "Scroll Bar", defaultValue: false }, showProgressDots: { type: ControlType4.Boolean, title: "Dots", defaultValue: false, hidden: (props) => props.showScrollbar }, dotSize: { type: ControlType4.Number, title: "Size", min: 1, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsInset: { type: ControlType4.Number, title: "Inset", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsGap: { type: ControlType4.Number, title: "Gap", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsPadding: { type: ControlType4.Number, title: "Padding", min: 0, max: 100, defaultValue: 10, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsFill: { type: ControlType4.Color, title: "Fill", defaultValue: "#fff", hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsBackground: { type: ControlType4.Color, title: "Backdrop", defaultValue: "rgba(0,0,0,0.2)", hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsRadius: { type: ControlType4.Number, title: "Radius", min: 0, max: 200, defaultValue: 50, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsOpacity: { type: ControlType4.Number, title: "Opacity", min: 0, max: 1, defaultValue: 0.5, step: 0.1, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsActiveOpacity: { type: ControlType4.Number, title: "Current", min: 0, max: 1, defaultValue: 1, step: 0.1, displayStepper: true, hidden: (props) => !props.showProgressDots || props.showScrollbar }, dotsBlur: { type: ControlType4.Number, title: "Blur", min: 0, max: 50, defaultValue: 4, step: 1, hidden: (props) => !props.showProgressDots || props.showScrollbar } } }, arrowObject: { type: ControlType4.Object, title: "Arrows", controls: { showMouseControls: { type: ControlType4.Boolean, title: "Show", defaultValue: true }, arrowFill: { type: ControlType4.Color, title: "Fill", defaultValue: "rgba(0,0,0,0.2)", hidden: (props) => !props.showMouseControls }, leftArrow: { type: ControlType4.Image, title: "Previous", hidden: (props) => !props.showMouseControls }, rightArrow: { type: ControlType4.Image, title: "Next", hidden: (props) => !props.showMouseControls }, arrowSize: { type: ControlType4.Number, title: "Size", min: 0, max: 200, displayStepper: true, defaultValue: 40, hidden: (props) => !props.showMouseControls }, arrowRadius: { type: ControlType4.Number, title: "Radius", min: 0, max: 500, defaultValue: 40, hidden: (props) => !props.showMouseControls }, arrowPadding: { type: ControlType4.Number, title: "Inset", min: 0, max: 100, defaultValue: 20, displayStepper: true, hidden: (props) => !props.showMouseControls } } }, ariaLabel: { type: ControlType4.String, title: "Aria Label", placeholder: "Movies..." }, borderRadius: { type: ControlType4.Number, title: "Radius", min: 0, max: 500, displayStepper: true, defaultValue: 0 } });
function Dot({ currentScroll, scrollInfo, isSelected, selectedOpacity, opacity: unselectedOpacity, total, index, dotStyle: dotStyle2, buttonStyle, gap, padding, axis, directionModifier, ...props }) {
  const opacity = useTransform(currentScroll, (v) => {
    if (!scrollInfo.current?.scrollLength) {
      return index === 0 ? selectedOpacity : unselectedOpacity;
    }
    const currentScroll2 = v * directionModifier;
    const pageLength = scrollInfo.current?.scrollLength / total;
    const minScroll = pageLength * index;
    const maxScroll = minScroll + pageLength;
    const isSelected2 = currentScroll2 >= minScroll && (index < total - 1 ? currentScroll2 < maxScroll : index === total - 1);
    return isSelected2 ? selectedOpacity : unselectedOpacity;
  });
  const inlinePadding = gap / 2;
  let top = !axis && index > 0 ? inlinePadding : padding;
  let bottom = !axis && index !== total - 1 ? inlinePadding : padding;
  let right = axis && index !== total - 1 ? inlinePadding : padding;
  let left = axis && index > 0 ? inlinePadding : padding;
  return /* @__PURE__ */ _jsx("button", { "aria-label": `Scroll to page ${index + 1}`, type: "button", ...props, style: { ...buttonStyle, padding: `${top}px ${right}px ${bottom}px ${left}px` }, children: /* @__PURE__ */ _jsx(motion.div, { style: { ...dotStyle2, opacity } }) });
}
function Placeholder() {
  return /* @__PURE__ */ _jsxs("section", { style: placeholderStyles, children: [/* @__PURE__ */ _jsx("div", { style: emojiStyles, children: "\u2728" }), /* @__PURE__ */ _jsx("p", { style: titleStyles, children: "Connect to Content" }), /* @__PURE__ */ _jsx("p", { style: subtitleStyles, children: "Add layers or components to swipe between." })] });
}
function MouseStyles() {
  return /* @__PURE__ */ _jsx("div", { dangerouslySetInnerHTML: { __html: `<style>@media (pointer: fine) {
                .framer--carousel[data-show-scrollbar="false"]::-webkit-scrollbar {
                    display: none;
                    -webkit-appearance: none;
                    width: 0;
                    height: 0;
                }

                .framer--carousel[data-show-scrollbar="false"]::-webkit-scrollbar-thumb {
                    display: none;
                }

                .framer--carousel[data-show-scrollbar="false"] {
                    scrollbar-width: none;
                    scrollbar-height: none;
                }
            }</style>` } });
}
var placeholderStyles = { display: "flex", width: "100%", height: "100%", placeContent: "center", placeItems: "center", flexDirection: "column", color: "#96F", background: "rgba(136, 85, 255, 0.1)", fontSize: 11, overflow: "hidden", padding: "20px 20px 30px 20px" };
var emojiStyles = { fontSize: 32, marginBottom: 10 };
var titleStyles = { margin: 0, marginBottom: 10, fontWeight: 600, textAlign: "center" };
var subtitleStyles = { margin: 0, opacity: 0.7, maxWidth: 130, lineHeight: 1.5, textAlign: "center" };
var baseContainerStyle = { display: "flex", overflow: "hidden", width: "100%", height: "100%", position: "relative" };
var baseCarouselStyle = { padding: 0, margin: 0, listStyle: "none", position: "relative", display: "flex", flex: "1 1 100%", width: "100%", height: "100%" };
var baseButtonStyles = { border: "none", display: "flex", placeContent: "center", placeItems: "center", overflow: "hidden", background: "transparent", cursor: "pointer", margin: 0, padding: 0 };
var controlsStyles = { display: "flex", justifyContent: "space-between", alignItems: "center", position: "absolute", top: 0, left: 0, right: 0, bottom: 0, pointerEvents: "none", border: 0, padding: 0, margin: 0 };
var dotsContainerStyle = { display: "flex", placeContent: "center", placeItems: "center", overflow: "hidden", position: "absolute", pointerEvents: "auto" };
var dotStyle = { borderRadius: "50%", background: "white", cursor: "pointer", border: "none", placeContent: "center", placeItems: "center", padding: 0 };
function useWritingDirection() {
  const [writingDirection, setWritingDirection] = useState3("ltr");
  useEffect7(() => {
    if (window?.document?.documentElement?.dir === "rtl") {
      setWritingDirection("rtl");
    }
  }, []);
  return writingDirection;
}

export {
  defaultEvents,
  useOnEnter,
  useOnExit,
  useIsBrowserSafari,
  useRenderTarget,
  useIsOnCanvas,
  useRadius,
  borderRadiusControl,
  Carousel
};
